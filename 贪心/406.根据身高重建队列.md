如果按照k来从小到大排序，排完之后，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。

那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。

此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！

局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性

全局最优：最后都做完插入操作，整个队列满足题目队列属性

回归本题，整个插入过程如下：

排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]

插入的过程：

插入[7,0]：[[7,0]]

插入[7,1]：[[7,0],[7,1]]

插入[6,1]：[[7,0],[6,1],[7,1]]

插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]

插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]

插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        people.sort(key= lambda x:(-x[0],x[1]))
        que = []
        for p in people:
            que.insert(p[1], p)
        
        return que
```
